import { GraphQLClient } from "graphql-request";

// Validate required environment variables
const hasuraUrl = process.env.HASURA_URL;
const hasuraAdminSecret = process.env.HASURA_ADMIN_SECRET;

// Make Hasura optional during startup to handle service dependency issues
let hasuraClient: GraphQLClient | null = null;

if (!hasuraUrl) {
  console.warn(
    "HASURA_URL environment variable is not set - Hasura features will be disabled"
  );
} else if (!hasuraAdminSecret) {
  console.warn(
    "HASURA_ADMIN_SECRET environment variable is not set - Hasura features will be disabled"
  );
} else {
  // Hasura GraphQL client configuration - append /v1/graphql to the base URL
  const hasuraGraphQLUrl = hasuraUrl.endsWith("/")
    ? `${hasuraUrl}v1/graphql`
    : `${hasuraUrl}/v1/graphql`;

  hasuraClient = new GraphQLClient(hasuraGraphQLUrl, {
    headers: {
      "x-hasura-admin-secret": hasuraAdminSecret,
    },
  });
  console.log(
    `Hasura client initialized successfully with URL: ${hasuraGraphQLUrl}`
  );
}

// GraphQL queries and mutations
export const GET_APP_METADATA = `
  query GetVersions($env: String!) {
    app_metadata(where: {environment: {_eq: $env}}) {
      component
      version
      deployed_at
      git_commit
      metadata
    }
  }
`;

export const RECORD_HEALTH_SNAPSHOT = `
  mutation RecordHealthSnapshot($snapshot: health_snapshots_insert_input!) {
    insert_health_snapshots_one(object: $snapshot) {
      id
      timestamp
    }
  }
`;

export const UPDATE_APP_METADATA = `
  mutation UpdateAppMetadata($component: String!, $version: String!, $environment: String!, $git_commit: String, $metadata: jsonb) {
    insert_app_metadata_one(
      object: {
        component: $component
        version: $version
        environment: $environment
        git_commit: $git_commit
        metadata: $metadata
      }
      on_conflict: {
        constraint: app_metadata_component_environment_key
        update_columns: [version, deployed_at, git_commit, metadata]
      }
    ) {
      id
      component
      version
      deployed_at
    }
  }
`;

// Activity log queries and mutations (auto-generated by Hasura)
export const LOG_ACTIVITY = `
  mutation LogActivity($action: String!) {
    insert_activity_log_one(object: {action: $action}) {
      id
      timestamp
      action
    }
  }
`;

export const LOG_ACTIVITIES_BULK = `
  mutation LogActivitiesBulk($activities: [activity_log_insert_input!]!) {
    insert_activity_log(objects: $activities) {
      affected_rows
      returning {
        id
        action
        timestamp
      }
    }
  }
`;

export const GET_RECENT_ACTIVITIES = `
  query GetRecentActivities($limit: Int = 20) {
    activity_log(
      order_by: {timestamp: desc}
      limit: $limit
    ) {
      id
      timestamp
      action
    }
  }
`;

export const GET_ACTIVITIES_BY_ACTION = `
  query GetActivitiesByAction($actions: [String!]) {
    activity_log(
      where: {
        action: {_in: $actions}
        timestamp: {_gte: "2024-01-01"}
      }
      order_by: {timestamp: desc}
    ) {
      id
      timestamp
      action
    }
  }
`;

// Interface definitions for type safety
export interface AppMetadata {
  component: string;
  version: string;
  deployed_at: string;
  git_commit?: string;
  metadata?: Record<string, unknown>;
}

export interface HealthSnapshot {
  overall_status: "up" | "down" | "degraded";
  component_statuses: Record<string, string>;
  response_times?: Record<string, number>;
  errors?: Record<string, unknown>;
}

// Hasura client functions
export class HasuraService {
  private client: GraphQLClient | null;
  private available: boolean = false;

  constructor() {
    this.client = hasuraClient;
    this.available = hasuraClient !== null;
  }

  /**
   * Fetch application metadata for a specific environment
   */
  async getAppMetadata(
    environment: string = "production"
  ): Promise<AppMetadata[]> {
    if (!this.client) {
      console.warn("Hasura client not available - returning empty metadata");
      return [];
    }

    try {
      const response = await this.client.request<{
        app_metadata: AppMetadata[];
      }>(GET_APP_METADATA, { env: environment });
      this.available = true;
      return response.app_metadata;
    } catch (error) {
      console.error("Failed to fetch app metadata from Hasura:", error);
      this.available = false;
      return [];
    }
  }

  /**
   * Record a health check snapshot for historical analysis
   */
  async recordHealthSnapshot(snapshot: HealthSnapshot): Promise<boolean> {
    if (!this.client) {
      console.warn(
        "Hasura client not available - skipping health snapshot recording"
      );
      return false;
    }

    try {
      await this.client.request(RECORD_HEALTH_SNAPSHOT, { snapshot });
      return true;
    } catch (error) {
      console.error("Failed to record health snapshot:", error);
      return false;
    }
  }

  /**
   * Update application metadata (typically called during deployment)
   */
  async updateAppMetadata(
    component: string,
    version: string,
    environment: string = "production",
    gitCommit?: string,
    metadata?: Record<string, unknown>
  ): Promise<boolean> {
    if (!this.client) {
      console.warn("Hasura client not available - skipping metadata update");
      return false;
    }

    try {
      await this.client.request(UPDATE_APP_METADATA, {
        component,
        version,
        environment,
        git_commit: gitCommit,
        metadata,
      });
      return true;
    } catch (error) {
      console.error("Failed to update app metadata:", error);
      return false;
    }
  }

  /**
   * Check if Hasura is available
   */
  isAvailable(): boolean {
    return this.available;
  }

  /**
   * Test Hasura connection with a simple query
   */
  async testConnection(): Promise<boolean> {
    if (!this.client) {
      return false;
    }

    try {
      // Simple introspection query to test connection
      await this.client.request(`query { __schema { queryType { name } } }`);
      this.available = true;
      return true;
    } catch (error) {
      console.error("Hasura connection test failed:", error);
      this.available = false;
      return false;
    }
  }

  /**
   * Track a table in Hasura to auto-generate CRUD operations
   */
  async trackTable(tableName: string): Promise<boolean> {
    if (!this.client) {
      console.warn("Hasura client not available - cannot track table");
      return false;
    }

    try {
      // Use Hasura metadata API to track table
      const hasuraUrl = process.env.HASURA_URL?.replace("/v1/graphql", "");
      const metadataUrl = `${hasuraUrl}/v1/metadata`;

      const response = await fetch(metadataUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-hasura-admin-secret": process.env.HASURA_ADMIN_SECRET || "",
        },
        body: JSON.stringify({
          type: "pg_track_table",
          args: {
            source: "default",
            table: {
              name: tableName,
              schema: "public",
            },
          },
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error(`Failed to track table ${tableName}: ${errorText}`);
        return false;
      }

      console.log(`âœ… Successfully tracked table: ${tableName}`);
      return true;
    } catch (error) {
      console.error(`Failed to track table ${tableName}:`, error);
      return false;
    }
  }

  /**
   * Get list of currently tracked tables
   */
  async getTrackedTables(): Promise<Array<{ name: string; schema: string }>> {
    if (!this.client) {
      console.warn("Hasura client not available - returning empty tables list");
      return [];
    }

    try {
      const response = await this.client.request<{
        __schema: {
          queryType: {
            fields: Array<{ name: string }>;
          };
        };
      }>(`
        query GetTrackedTables {
          __schema {
            queryType {
              fields {
                name
              }
            }
          }
        }
      `);

      // Filter out system fields to get actual table names
      const tableFields = response.__schema.queryType.fields
        .filter((field) => !field.name.startsWith("__"))
        .filter((field) => !field.name.endsWith("_aggregate"))
        .filter((field) => !field.name.endsWith("_by_pk"))
        .map((field) => ({ name: field.name, schema: "public" }));

      return tableFields;
    } catch (error) {
      console.error("Failed to get tracked tables:", error);
      return [];
    }
  }
}

// Export singleton instance
export const hasuraService = new HasuraService();
export default hasuraService;
